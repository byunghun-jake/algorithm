# 힙

1. 우선순위 큐를 위해 만들어진 자료구조인 힙(heap)에 대해 이해한다.
2. 배열을 이용해 힙을 구현할 수 있다.
3. 힙의 삽입 / 삭제를 이해한다.



### 우선순위 큐란?

- 데이터들이 우선순위(가중치)를 가지고 있고, 우선순위가 높은 데이터가 먼저 나간다.

    | 자료구조     | 빠져 나가는(삭제되는) 순서      |
    | ------------ | ------------------------------- |
    | 스택 (Stack) | 가장 최근에(늦게) 들어온 데이터 |
    | 큐 (Queue)   | 가장 먼저 들어온 데이터         |
    | 힙 (Heap)    | 가장 우선순위가 높은 데이터     |



- 우선순위 큐의 활용 사례
  1. 시뮬레이션 시스템
  2. 네트워크 트래픽 제어
  3. 운영 체제에서의 작업 스케쥴링
  4. 수치 해석적인 계산



- 우선순위 큐는 배열, 연결 리스트, 힙으로 구현이 가능하다. 이 중에서 힙(heap)으로 구현하는 것이 가장 효율적이다.

  | 우선순위 큐 구현 방법 | 삽입                             | 삭제    |
  | --------------------- | -------------------------------- | ------- |
  | 순서 없는 배열        | O(1)                             | O(n)    |
  | 순서 없는 연결 리스트 | O(1)                             | O(n)    |
  | 정렬된 배열           | O(n)<br />정렬해주어야 하기 때문 | O(1)    |
  | 정렬된 연결 리스트    | O(n)                             | O(1)    |
  | 힙                    | O(logn)                          | O(logn) |



### 자료구조 "힙"이란?

- 완전 이진 트리
- 우선순위 큐를 위해 만들어진 자료구조
- 여러 개의 값들 중에서 최대값이나 최소값을 빠르게 찾아낼 수 있다.
- 반정렬 상태를 유지한다.
  - 최대 힙의 경우
    - 큰 값이 상위 레벨에 있고, 작은 값이 하위 레벨에 있다.
    - 부모 노드의 키 값이 자식 노드의 키 값보다 항상 크다.
  - 최소 힙의 경우는 반대
- 중복된 값을 허용한다.



#### 구현

- 힙을 저장하는 표준 자료구조는 "배열"이다.

- 구현을 쉽게 하기 위해 인덱스 0은 사용하지 않는다.

- 부모 노드와 자식 노드의 관계

  1. 부모 노드의 인덱스가 N일 때,
     - 왼쪽 자식 노드의 인덱스는 `2 * N`
     - 오른쪽 자식 노드의 인덱스는 `(2 * N) + 1`

  2. 자식 노드의 인덱스가 N일 때,
     - 부모 노드의 인덱스는 `N // 2`



#### 삽입 (최대 힙)

1. 가장 마지막 인덱스 + 1 위치에 값을 입력한다.

2. 부모 노드와 값을 비교한다.

   - 부모 노드의 값 >=  자식 노드의 값

     삽입 완료

   - 부모 노드의 값 < 자식 노드의 값

     두 값을 바꿔준다.

     값이 변경된 부모노드에서 2를 다시 수행한다.

```python
# 새로 값이 입력되었다.
heap[idx] = n

while (idx != 1) and (heap[idx] > heap[idx//2]):
    heap[idx], heap[idx // 2] = heap[idx // 2], heap[idx]
    idx //= 2
```



#### 삭제 (최대 힙)

1. 1번째 인덱스의 값을 꺼낸 뒤, 마지막 노드에 있는 값을 1번째 인덱스에 넣는다.
2. 자식 노드의 값 중 더 큰 값과 비교를 수행
   - 부모 노드의 값이 크다면 비교 종료
   - 자식 노드의 값이 크다면 값을 교환하고 2번 과정을 반복

```python
heap[1], heap[-1] = heap[-1], heap[1]
print(heap.pop())
idx = 1
while idx < len(heap):
    # 더 큰 자식 노드 찾기
    max_idx = idx
    lc_idx = idx * 2
    rc_idx = lc_idx + 1
    if lc_idx <= len(heap) and heap[max_idx] < heap[lc_idx]:
        max_idx = lc_idx
    if rc_idx <= len(heap) and heap[max_idx] < heap[rc_idx]:
        max_idx = rc_idx
    if max_idx != idx:
        heap[idx], heap[max_idx] = heap[max_idx], heap[idx]
        idx = max_idx
    else:
        break
```























